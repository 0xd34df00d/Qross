//Auto-generated by kalyptus. DO NOT EDIT.
namespace Qyoto {
    using System;
    [SmokeClass("QTextBlock")]
    public class QTextBlock : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected QTextBlock(Type dummy) {}
        [SmokeClass("QTextBlock::iterator")]
        public class iterator : Object, IDisposable {
            protected SmokeInvocation interceptor = null;
            private IntPtr smokeObject;
            protected iterator(Type dummy) {}
            protected void CreateProxy() {
                interceptor = new SmokeInvocation(typeof(iterator), this);
            }
            private static SmokeInvocation staticInterceptor = null;
            static iterator() {
                staticInterceptor = new SmokeInvocation(typeof(iterator), null);
            }
            public iterator() : this((Type) null) {
                CreateProxy();
                interceptor.Invoke("iterator", "iterator()", typeof(void));
            }
            public iterator(QTextBlock.iterator o) : this((Type) null) {
                CreateProxy();
                interceptor.Invoke("iterator#", "iterator(const QTextBlock::iterator&)", typeof(void), typeof(QTextBlock.iterator), o);
            }
            public QTextFragment Fragment() {
                return (QTextFragment) interceptor.Invoke("fragment", "fragment() const", typeof(QTextFragment));
            }
            public bool AtEnd() {
                return (bool) interceptor.Invoke("atEnd", "atEnd() const", typeof(bool));
            }
            public override bool Equals(object o) {
                if (!(o is iterator)) { return false; }
                return this == (iterator) o;
            }
            public override int GetHashCode() {
                return interceptor.GetHashCode();
            }
            ~iterator() {
                interceptor.Invoke("~iterator", "~iterator()", typeof(void));
            }
            public void Dispose() {
                interceptor.Invoke("~iterator", "~iterator()", typeof(void));
            }
            public static bool operator==(iterator lhs, QTextBlock.iterator o) {
                return (bool) staticInterceptor.Invoke("operator==#", "operator==(const QTextBlock::iterator&) const", typeof(bool), typeof(iterator), lhs, typeof(QTextBlock.iterator), o);
            }
            public static bool operator!=(iterator lhs, QTextBlock.iterator o) {
                return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const QTextBlock::iterator&) const", typeof(bool), typeof(iterator), lhs, typeof(QTextBlock.iterator), o);
            }
            public static QTextBlock.iterator operator++(iterator lhs) {
                return (QTextBlock.iterator) staticInterceptor.Invoke("operator++", "operator++()", typeof(QTextBlock.iterator), typeof(iterator), lhs);
            }
            public static QTextBlock.iterator operator--(iterator lhs) {
                return (QTextBlock.iterator) staticInterceptor.Invoke("operator--", "operator--()", typeof(QTextBlock.iterator), typeof(iterator), lhs);
            }
        }
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(QTextBlock), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static QTextBlock() {
            staticInterceptor = new SmokeInvocation(typeof(QTextBlock), null);
        }
        // QTextBlock* QTextBlock(QTextDocumentPrivate* arg1,int arg2); >>>> NOT CONVERTED
        // QTextDocumentPrivate* docHandle(); >>>> NOT CONVERTED
        public QTextBlock() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QTextBlock", "QTextBlock()", typeof(void));
        }
        public QTextBlock(QTextBlock o) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QTextBlock#", "QTextBlock(const QTextBlock&)", typeof(void), typeof(QTextBlock), o);
        }
        public bool IsValid() {
            return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
        }
        public override bool Equals(object o) {
            if (!(o is QTextBlock)) { return false; }
            return this == (QTextBlock) o;
        }
        public override int GetHashCode() {
            return interceptor.GetHashCode();
        }
        public int Position() {
            return (int) interceptor.Invoke("position", "position() const", typeof(int));
        }
        public int Length() {
            return (int) interceptor.Invoke("length", "length() const", typeof(int));
        }
        public bool Contains(int position) {
            return (bool) interceptor.Invoke("contains$", "contains(int) const", typeof(bool), typeof(int), position);
        }
        public QTextLayout Layout() {
            return (QTextLayout) interceptor.Invoke("layout", "layout() const", typeof(QTextLayout));
        }
        public void ClearLayout() {
            interceptor.Invoke("clearLayout", "clearLayout()", typeof(void));
        }
        public QTextBlockFormat BlockFormat() {
            return (QTextBlockFormat) interceptor.Invoke("blockFormat", "blockFormat() const", typeof(QTextBlockFormat));
        }
        public int BlockFormatIndex() {
            return (int) interceptor.Invoke("blockFormatIndex", "blockFormatIndex() const", typeof(int));
        }
        public QTextCharFormat CharFormat() {
            return (QTextCharFormat) interceptor.Invoke("charFormat", "charFormat() const", typeof(QTextCharFormat));
        }
        public int CharFormatIndex() {
            return (int) interceptor.Invoke("charFormatIndex", "charFormatIndex() const", typeof(int));
        }
        public string Text() {
            return (string) interceptor.Invoke("text", "text() const", typeof(string));
        }
        public QTextDocument Document() {
            return (QTextDocument) interceptor.Invoke("document", "document() const", typeof(QTextDocument));
        }
        public QTextList TextList() {
            return (QTextList) interceptor.Invoke("textList", "textList() const", typeof(QTextList));
        }
        public QTextBlockUserData UserData() {
            return (QTextBlockUserData) interceptor.Invoke("userData", "userData() const", typeof(QTextBlockUserData));
        }
        public void SetUserData(QTextBlockUserData data) {
            interceptor.Invoke("setUserData#", "setUserData(QTextBlockUserData*)", typeof(void), typeof(QTextBlockUserData), data);
        }
        public int UserState() {
            return (int) interceptor.Invoke("userState", "userState() const", typeof(int));
        }
        public void SetUserState(int state) {
            interceptor.Invoke("setUserState$", "setUserState(int)", typeof(void), typeof(int), state);
        }
        public int Revision() {
            return (int) interceptor.Invoke("revision", "revision() const", typeof(int));
        }
        public void SetRevision(int rev) {
            interceptor.Invoke("setRevision$", "setRevision(int)", typeof(void), typeof(int), rev);
        }
        public bool IsVisible() {
            return (bool) interceptor.Invoke("isVisible", "isVisible() const", typeof(bool));
        }
        public void SetVisible(bool visible) {
            interceptor.Invoke("setVisible$", "setVisible(bool)", typeof(void), typeof(bool), visible);
        }
        public int BlockNumber() {
            return (int) interceptor.Invoke("blockNumber", "blockNumber() const", typeof(int));
        }
        public int FirstLineNumber() {
            return (int) interceptor.Invoke("firstLineNumber", "firstLineNumber() const", typeof(int));
        }
        public void SetLineCount(int count) {
            interceptor.Invoke("setLineCount$", "setLineCount(int)", typeof(void), typeof(int), count);
        }
        public int LineCount() {
            return (int) interceptor.Invoke("lineCount", "lineCount() const", typeof(int));
        }
        public QTextBlock.iterator Begin() {
            return (QTextBlock.iterator) interceptor.Invoke("begin", "begin() const", typeof(QTextBlock.iterator));
        }
        public QTextBlock.iterator End() {
            return (QTextBlock.iterator) interceptor.Invoke("end", "end() const", typeof(QTextBlock.iterator));
        }
        public QTextBlock Next() {
            return (QTextBlock) interceptor.Invoke("next", "next() const", typeof(QTextBlock));
        }
        public QTextBlock Previous() {
            return (QTextBlock) interceptor.Invoke("previous", "previous() const", typeof(QTextBlock));
        }
        public int FragmentIndex() {
            return (int) interceptor.Invoke("fragmentIndex", "fragmentIndex() const", typeof(int));
        }
        ~QTextBlock() {
            interceptor.Invoke("~QTextBlock", "~QTextBlock()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~QTextBlock", "~QTextBlock()", typeof(void));
        }
        public static bool operator==(QTextBlock lhs, QTextBlock o) {
            return (bool) staticInterceptor.Invoke("operator==#", "operator==(const QTextBlock&) const", typeof(bool), typeof(QTextBlock), lhs, typeof(QTextBlock), o);
        }
        public static bool operator!=(QTextBlock lhs, QTextBlock o) {
            return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const QTextBlock&) const", typeof(bool), typeof(QTextBlock), lhs, typeof(QTextBlock), o);
        }
        public static bool operator<(QTextBlock lhs, QTextBlock o) {
            return (bool) staticInterceptor.Invoke("operator<#", "operator<(const QTextBlock&) const", typeof(bool), typeof(QTextBlock), lhs, typeof(QTextBlock), o);
        }
        public static bool operator>(QTextBlock lhs, QTextBlock o) {
            return !(bool) staticInterceptor.Invoke("operator<#", "operator<(const QTextBlock&) const", typeof(bool), typeof(QTextBlock), lhs, typeof(QTextBlock), o)
                        && !(bool) staticInterceptor.Invoke("operator==#", "operator==(const QTextBlock&) const", typeof(bool), typeof(QTextBlock), lhs, typeof(QTextBlock), o);
        }
    }
}
