//Auto-generated by kalyptus. DO NOT EDIT.
namespace Qyoto {
    using System;
    using System.Collections.Generic;
    /// <remarks> See <see cref="IQAbstractEventDispatcherSignals"></see> for signals emitted by QAbstractEventDispatcher
    /// </remarks>
    [SmokeClass("QAbstractEventDispatcher")]
    public abstract class QAbstractEventDispatcher : QObject {
        protected QAbstractEventDispatcher(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(QAbstractEventDispatcher), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static QAbstractEventDispatcher() {
            staticInterceptor = new SmokeInvocation(typeof(QAbstractEventDispatcher), null);
        }
        // EventFilter setEventFilter(EventFilter arg1); >>>> NOT CONVERTED
        // bool filterEvent(void* arg1); >>>> NOT CONVERTED
        // QAbstractEventDispatcher* instance(QThread* arg1); >>>> NOT CONVERTED
        // QAbstractEventDispatcher* QAbstractEventDispatcher(QAbstractEventDispatcherPrivate& arg1,QObject* arg2); >>>> NOT CONVERTED
        public QAbstractEventDispatcher(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QAbstractEventDispatcher#", "QAbstractEventDispatcher(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public QAbstractEventDispatcher() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("QAbstractEventDispatcher", "QAbstractEventDispatcher()", typeof(void));
        }
        [SmokeMethod("processEvents(QEventLoop::ProcessEventsFlags)")]
        public abstract bool ProcessEvents(uint flags);
        [SmokeMethod("hasPendingEvents()")]
        public abstract bool HasPendingEvents();
        [SmokeMethod("registerSocketNotifier(QSocketNotifier*)")]
        public abstract void RegisterSocketNotifier(QSocketNotifier notifier);
        [SmokeMethod("unregisterSocketNotifier(QSocketNotifier*)")]
        public abstract void UnregisterSocketNotifier(QSocketNotifier notifier);
        public int RegisterTimer(int interval, QObject arg2) {
            return (int) interceptor.Invoke("registerTimer$#", "registerTimer(int, QObject*)", typeof(int), typeof(int), interval, typeof(QObject), arg2);
        }
        [SmokeMethod("registerTimer(int, int, QObject*)")]
        public abstract void RegisterTimer(int timerId, int interval, QObject arg3);
        [SmokeMethod("unregisterTimer(int)")]
        public abstract bool UnregisterTimer(int timerId);
        [SmokeMethod("unregisterTimers(QObject*)")]
        public abstract bool UnregisterTimers(QObject arg1);
        [SmokeMethod("registeredTimers(QObject*) const")]
        public abstract List<QPair<int, int>> RegisteredTimers(QObject arg1);
        [SmokeMethod("wakeUp()")]
        public abstract void WakeUp();
        [SmokeMethod("interrupt()")]
        public abstract void Interrupt();
        [SmokeMethod("flush()")]
        public abstract void Flush();
        [SmokeMethod("startingUp()")]
        public virtual void StartingUp() {
            interceptor.Invoke("startingUp", "startingUp()", typeof(void));
        }
        [SmokeMethod("closingDown()")]
        public virtual void ClosingDown() {
            interceptor.Invoke("closingDown", "closingDown()", typeof(void));
        }
        public static new string Tr(string s, string c) {
            return (string) staticInterceptor.Invoke("tr$$", "tr(const char*, const char*)", typeof(string), typeof(string), s, typeof(string), c);
        }
        public static new string Tr(string s) {
            return (string) staticInterceptor.Invoke("tr$", "tr(const char*)", typeof(string), typeof(string), s);
        }
        protected new IQAbstractEventDispatcherSignals Emit {
            get { return (IQAbstractEventDispatcherSignals) Q_EMIT; }
        }
    }

    public interface IQAbstractEventDispatcherSignals : IQObjectSignals {
        [Q_SIGNAL("void aboutToBlock()")]
        void AboutToBlock();
        [Q_SIGNAL("void awake()")]
        void Awake();
    }
}
