//Auto-generated by kalyptus. DO NOT EDIT.
namespace Phonon {
    using Phonon;
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks> \class Effect effect.h Phonon/Effect
    ///  \short Effects that can be inserted into a Path.
    ///  An effect is a special object which can perform
    ///  transformations on the specified path. Examples may include simple
    ///  modifiers such as fading or pitch shifting, or more complex mathematical
    ///  transformations.
    ///  In order to use an effect, insert it into the path as follows:
    ///  <pre>
    ///  Path path = Phonon.CreatePath(...);
    ///  Effect effect = new Effect(this);
    ///  path.insertEffect(effect);
    ///  </pre>
    ///  The effect will immediately begin applying it's transformations on
    ///  the path. To stop it, remove the Effect from the path.
    ///  \ingroup PhononEffects
    ///  \author Matthias Kretz <kretz@kde.org>
    ///      </remarks>        <short>   \class Effect effect.</short>
    [SmokeClass("Phonon::Effect")]
    public class Effect : QObject, Phonon.IMediaNode, IDisposable {
        protected Effect(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(Effect), this);
        }
        // Phonon::Effect* Effect(const Phonon::ObjectDescription<Phonon::EffectType>& arg1,QObject* arg2); >>>> NOT CONVERTED
        // Phonon::Effect* Effect(const Phonon::ObjectDescription<Phonon::EffectType>& arg1); >>>> NOT CONVERTED
        // Phonon::ObjectDescription<Phonon::EffectType> description(); >>>> NOT CONVERTED
        // Phonon::Effect* Effect(Phonon::EffectPrivate& arg1,QObject* arg2); >>>> NOT CONVERTED
        // Phonon::MediaNode* MediaNode(Phonon::MediaNodePrivate& arg1); >>>> NOT CONVERTED
        /// <remarks>
        ///  QObject constructor.
        ///  \param description An EffectDescription object to determine the
        ///  type of effect. See BackendCapabilities.AvailableAudioEffects().
        ///  \param parent QObject parent
        ///              </remarks>        <short>    QObject constructor.</short>
        /// <remarks>
        ///  Returns the description of this effect. This is the same type as was
        ///  passed to the constructor.
        ///              </remarks>        <short>    Returns the description of this effect.</short>
        /// <remarks>
        ///  Returns a list of parameters that this effect provides to control
        ///  its behaviour.
        ///  \see EffectParameter
        ///  \see EffectWidget
        ///              </remarks>        <short>    Returns a list of parameters that this effect provides to control  its behaviour.</short>
        public List<Phonon.EffectParameter> Parameters() {
            return (List<Phonon.EffectParameter>) interceptor.Invoke("parameters", "parameters() const", typeof(List<Phonon.EffectParameter>));
        }
        public QVariant ParameterValue(Phonon.EffectParameter arg1) {
            return (QVariant) interceptor.Invoke("parameterValue#", "parameterValue(const Phonon::EffectParameter&) const", typeof(QVariant), typeof(Phonon.EffectParameter), arg1);
        }
        public void SetParameterValue(Phonon.EffectParameter arg1, QVariant value) {
            interceptor.Invoke("setParameterValue##", "setParameterValue(const Phonon::EffectParameter&, const QVariant&)", typeof(void), typeof(Phonon.EffectParameter), arg1, typeof(QVariant), value);
        }
        ~Effect() {
            interceptor.Invoke("~Effect", "~Effect()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~Effect", "~Effect()", typeof(void));
        }
        /// <remarks>
        ///  Tells whether the backend provides an implementation of this
        ///  class.
        ///  \return <code>true</code> if backend provides an implementation
        ///  \return <code>false</code> if the object is not implemented by the backend
        ///          </remarks>        <short>    Tells whether the backend provides an implementation of this  class.</short>
        public bool IsValid() {
            return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
        }
        public List<Phonon.Path> InputPaths() {
            return (List<Phonon.Path>) interceptor.Invoke("inputPaths", "inputPaths() const", typeof(List<Phonon.Path>));
        }
        public List<Phonon.Path> OutputPaths() {
            return (List<Phonon.Path>) interceptor.Invoke("outputPaths", "outputPaths() const", typeof(List<Phonon.Path>));
        }
        protected new IEffectSignals Emit {
            get { return (IEffectSignals) Q_EMIT; }
        }
    }

    public interface IEffectSignals : IQObjectSignals {
    }
}
