//Auto-generated by kalyptus. DO NOT EDIT.
namespace Phonon {
    using Phonon;
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks> \internal
    ///  \class ObjectDescriptionData objectdescription.h Phonon/ObjectDescription
    ///  \brief Data class for objects describing devices or features of the backend.
    ///  \author Matthias Kretz <kretz@kde.org>
    ///  \see BackendCapabilities
    ///  </remarks>        <short>   \internal  \class ObjectDescriptionData objectdescription.</short>
    [SmokeClass("Phonon::ObjectDescriptionData")]
    public class ObjectDescriptionData : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected ObjectDescriptionData(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(ObjectDescriptionData), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static ObjectDescriptionData() {
            staticInterceptor = new SmokeInvocation(typeof(ObjectDescriptionData), null);
        }
        // Phonon::ObjectDescriptionData* ObjectDescriptionData(Phonon::ObjectDescriptionPrivate* arg1); >>>> NOT CONVERTED
        // Phonon::ObjectDescriptionData* ObjectDescriptionData(int arg1,const QHash<QByteArray, QVariant>& arg2); >>>> NOT CONVERTED
        /// <remarks>
        ///  Returns <code>true</code> if this ObjectDescription describes the same
        ///  as <pre>otherDescription</pre>; otherwise returns <code>false</code>.
        ///          </remarks>        <short>    Returns <code>true</code> if this ObjectDescription describes the same  as \p otherDescription; otherwise returns <code>false</code>.</short>
        public override bool Equals(object o) {
            if (!(o is ObjectDescriptionData)) { return false; }
            return this == (ObjectDescriptionData) o;
        }
        public override int GetHashCode() {
            return interceptor.GetHashCode();
        }
        /// <remarks>
        ///  Returns the name of the capture source.
        ///  \return A string that should be presented to the user to
        ///  choose the capture source.
        ///          </remarks>        <short>    Returns the name of the capture source.</short>
        public string Name() {
            return (string) interceptor.Invoke("name", "name() const", typeof(string));
        }
        /// <remarks>
        ///  Returns a description of the capture source. This text should
        ///  make clear what sound source this is, which is sometimes hard
        ///  to describe or understand from just the name.
        ///  \return A string describing the capture source.
        ///          </remarks>        <short>    Returns a description of the capture source.</short>
        public string Description() {
            return (string) interceptor.Invoke("description", "description() const", typeof(string));
        }
        /// <remarks>
        ///  Returns a named property.
        ///  If the property is not set an invalid value is returned.
        ///  \see propertyNames()
        ///          </remarks>        <short>    Returns a named property.</short>
        public QVariant Property(string name) {
            return (QVariant) interceptor.Invoke("property$", "property(const char*) const", typeof(QVariant), typeof(string), name);
        }
        /// <remarks>
        ///  Returns all names that return valid data when property() is called.
        ///  \see property()
        ///          </remarks>        <short>    Returns all names that return valid data when property() is called.</short>
        public List<QByteArray> PropertyNames() {
            return (List<QByteArray>) interceptor.Invoke("propertyNames", "propertyNames() const", typeof(List<QByteArray>));
        }
        /// <remarks>
        ///  Returns <code>true</code> if the Tuple is valid (index != -1); otherwise returns
        ///  <code>false</code>.
        ///          </remarks>        <short>    Returns <code>true</code> if the Tuple is valid (index != -1); otherwise returns  <code>false</code>.</short>
        public bool IsValid() {
            return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
        }
        /// <remarks>
        ///  A unique identifier for this device/. Used internally
        ///  to distinguish between the devices/.
        ///  \return An integer that uniquely identifies every device/
        ///          </remarks>        <short>    A unique identifier for this device/.</short>
        public int Index() {
            return (int) interceptor.Invoke("index", "index() const", typeof(int));
        }
        ~ObjectDescriptionData() {
            interceptor.Invoke("~ObjectDescriptionData", "~ObjectDescriptionData()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~ObjectDescriptionData", "~ObjectDescriptionData()", typeof(void));
        }
        public static bool operator==(ObjectDescriptionData lhs, Phonon.ObjectDescriptionData otherDescription) {
            return (bool) staticInterceptor.Invoke("operator==#", "operator==(const Phonon::ObjectDescriptionData&) const", typeof(bool), typeof(ObjectDescriptionData), lhs, typeof(Phonon.ObjectDescriptionData), otherDescription);
        }
        public static bool operator!=(ObjectDescriptionData lhs, Phonon.ObjectDescriptionData otherDescription) {
            return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const Phonon::ObjectDescriptionData&) const", typeof(bool), typeof(ObjectDescriptionData), lhs, typeof(Phonon.ObjectDescriptionData), otherDescription);
        }
        public static Phonon.ObjectDescriptionData FromIndex(Phonon.ObjectDescriptionType type, int index) {
            return (Phonon.ObjectDescriptionData) staticInterceptor.Invoke("fromIndex$$", "fromIndex(Phonon::ObjectDescriptionType, int)", typeof(Phonon.ObjectDescriptionData), typeof(Phonon.ObjectDescriptionType), type, typeof(int), index);
        }
    }
}
