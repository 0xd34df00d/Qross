//Auto-generated by kalyptus. DO NOT EDIT.
namespace Phonon {
    using Phonon;
    using System;
    using Qyoto;
    /// <remarks> \class AudioOutput audiooutput.h Phonon/AudioOutput
    ///  \short Class for audio output to the soundcard.
    ///  Use this class to define the audio output.
    ///  \ingroup Frontend
    ///  \author Matthias Kretz <kretz@kde.org>
    ///  \see Phonon.Ui.VolumeSlider
    ///       See <see cref="IAudioOutputSignals"></see> for signals emitted by AudioOutput
    /// </remarks>        <short>   \class AudioOutput audiooutput.</short>
    [SmokeClass("Phonon::AudioOutput")]
    public class AudioOutput : Phonon.AbstractAudioOutput, IDisposable {
        protected AudioOutput(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(AudioOutput), this);
        }
        [Q_PROPERTY("QString", "name")]
        public string Name {
            get { return (string) interceptor.Invoke("name", "name()", typeof(string)); }
            set { interceptor.Invoke("setName$", "setName(QString)", typeof(void), typeof(string), value); }
        }
        [Q_PROPERTY("qreal", "volume")]
        public double Volume {
            get { return (double) interceptor.Invoke("volume", "volume()", typeof(double)); }
            set { interceptor.Invoke("setVolume$", "setVolume(qreal)", typeof(void), typeof(double), value); }
        }
        [Q_PROPERTY("qreal", "volumeDecibel")]
        public double VolumeDecibel {
            get { return (double) interceptor.Invoke("volumeDecibel", "volumeDecibel()", typeof(double)); }
            set { interceptor.Invoke("setVolumeDecibel$", "setVolumeDecibel(qreal)", typeof(void), typeof(double), value); }
        }
        [Q_PROPERTY("bool", "muted")]
        public bool Muted {
            get { return (bool) interceptor.Invoke("isMuted", "isMuted()", typeof(bool)); }
            set { interceptor.Invoke("setMuted$", "setMuted(bool)", typeof(void), typeof(bool), value); }
        }
        // bool setOutputDevice(const Phonon::ObjectDescription<Phonon::AudioOutputDeviceType>& arg1); >>>> NOT CONVERTED
        /// <remarks>
        ///  Creates a new AudioOutput that defines output to a physical
        ///  device.
        ///  \param category The category can be used by mixer applications to group volume
        ///  controls of applications into categories. That makes it easier for
        ///  the user to identify the programs.
        ///  The category is also used for the default output device that is
        ///  configured centrally. As an example: often users want to have the
        ///  audio signal of a VoIP application go to their USB headset while
        ///  all other sounds should go to the internal soundcard.
        ///  \param parent QObject parent
        ///  \see Phonon.CategoryToString
        ///  \see outputDevice
        ///              </remarks>        <short>    Creates a new AudioOutput that defines output to a physical  device.</short>
        public AudioOutput(Phonon.Category category, QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("AudioOutput$#", "AudioOutput(Phonon::Category, QObject*)", typeof(void), typeof(Phonon.Category), category, typeof(QObject), parent);
        }
        public AudioOutput(Phonon.Category category) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("AudioOutput$", "AudioOutput(Phonon::Category)", typeof(void), typeof(Phonon.Category), category);
        }
        public AudioOutput(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("AudioOutput#", "AudioOutput(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public AudioOutput() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("AudioOutput", "AudioOutput()", typeof(void));
        }
        /// <remarks>
        ///  Returns the category of this output.
        ///  \see AudioOutput(Phonon.Category, QObject )
        ///              </remarks>        <short>    Returns the category of this output.</short>
        public Phonon.Category category() {
            return (Phonon.Category) interceptor.Invoke("category", "category() const", typeof(Phonon.Category));
        }
        [Q_SLOT("void setName(QString)")]
        public void SetName(string newName) {
            interceptor.Invoke("setName$", "setName(const QString&)", typeof(void), typeof(string), newName);
        }
        [Q_SLOT("void setVolume(qreal)")]
        public void SetVolume(double newVolume) {
            interceptor.Invoke("setVolume$", "setVolume(qreal)", typeof(void), typeof(double), newVolume);
        }
        [Q_SLOT("void setVolumeDecibel(qreal)")]
        public void SetVolumeDecibel(double newVolumeDecibel) {
            interceptor.Invoke("setVolumeDecibel$", "setVolumeDecibel(qreal)", typeof(void), typeof(double), newVolumeDecibel);
        }
        [Q_SLOT("void setMuted(bool)")]
        public void SetMuted(bool mute) {
            interceptor.Invoke("setMuted$", "setMuted(bool)", typeof(void), typeof(bool), mute);
        }
        ~AudioOutput() {
            interceptor.Invoke("~AudioOutput", "~AudioOutput()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~AudioOutput", "~AudioOutput()", typeof(void));
        }
        protected new IAudioOutputSignals Emit {
            get { return (IAudioOutputSignals) Q_EMIT; }
        }
    }

    public interface IAudioOutputSignals : Phonon.IAbstractAudioOutputSignals {
        /// <remarks>
        ///  This signal is emitted whenever the volume has changed. As the
        ///  volume can change without a call to setVolume (calls over dbus)
        ///  this is important
        ///  to keep a widget showing the current volume up to date.
        ///              </remarks>        <short>    This signal is emitted whenever the volume has changed.</short>
        [Q_SIGNAL("void volumeChanged(qreal)")]
        void VolumeChanged(double newVolume);
        /// <remarks>
        ///  This signal is emitted when the muted property has changed. As
        ///  this property can change by IPC (DBus) calls a UI element showing
        ///  the muted property should listen to this signal.
        ///              </remarks>        <short>    This signal is emitted when the muted property has changed.</short>
        [Q_SIGNAL("void mutedChanged(bool)")]
        void MutedChanged(bool arg1);
        // void outputDeviceChanged(const Phonon::ObjectDescription<Phonon::AudioOutputDeviceType>& arg1); >>>> NOT CONVERTED
    }
}
