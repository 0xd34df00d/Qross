//Auto-generated by kalyptus. DO NOT EDIT.
namespace Phonon {
    using Phonon;
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks> \class EffectParameter effectparameter.h Phonon/EffectParameter
    ///  \brief This class describes one parameter of an effect.
    ///  \ingroup PhononEffects
    ///  \author Matthias Kretz <kretz@kde.org>
    ///  \see Effect
    ///  </remarks>        <short>   \class EffectParameter effectparameter.</short>
    [SmokeClass("Phonon::EffectParameter")]
    public class EffectParameter : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected EffectParameter(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(EffectParameter), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static EffectParameter() {
            staticInterceptor = new SmokeInvocation(typeof(EffectParameter), null);
        }
        /// <remarks>
        ///  Only for backend developers:
        ///  Flags to set the return values of isToggleControl(),
        ///  isLogarithmicControl(), isIntegerControl(), isBoundedBelow() and
        ///  isBoundedAbove(). The values of the flags correspond to the values
        ///  used for LADSPA effects.
        ///          </remarks>        <short>    Only for backend developers: </short>
        public enum Hint {
            ToggledHint = 0x04,
            LogarithmicHint = 0x10,
            IntegerHint = 0x20,
        }
        /// <remarks>
        ///  \internal
        ///  Creates an invalid effect parameter.
        ///          </remarks>        <short>    \internal </short>
        public EffectParameter() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("EffectParameter", "EffectParameter()", typeof(void));
        }
        /// <remarks>
        ///  The name of the parameter. Can be used as the label.
        ///  \return A label for the parameter.
        ///          </remarks>        <short>    The name of the parameter.</short>
        public string Name() {
            return (string) interceptor.Invoke("name", "name() const", typeof(string));
        }
        /// <remarks>
        ///  The parameter may come with a description (LADSPA doesn't have a
        ///  field for this, so don't expect many effects to provide a
        ///  description).
        ///  The description can be used for a tooltip or WhatsThis help.
        ///  \return A text describing the parameter.
        ///          </remarks>        <short>    The parameter may come with a description (LADSPA doesn't have a  field for this, so don't expect many effects to provide a  description).</short>
        public string Description() {
            return (string) interceptor.Invoke("description", "description() const", typeof(string));
        }
        /// <remarks>
        ///  Returns the parameter type.
        ///  Common types are QVariant.Int, QVariant.Double, QVariant.Bool and QVariant.String. When
        ///  QVariant.String is returned you get the possible values from possibleValues.
        ///          </remarks>        <short>    Returns the parameter type.</short>
        public QVariant.TypeOf type() {
            return (QVariant.TypeOf) interceptor.Invoke("type", "type() const", typeof(QVariant.TypeOf));
        }
        /// <remarks>
        ///  Returns whether the parameter should be
        ///  displayed using a logarithmic scale. This is particularly useful for
        ///  frequencies and gains.
        ///          </remarks>        <short>    Returns whether the parameter should be  displayed using a logarithmic scale.</short>
        public bool IsLogarithmicControl() {
            return (bool) interceptor.Invoke("isLogarithmicControl", "isLogarithmicControl() const", typeof(bool));
        }
        /// <remarks>
        ///  The minimum value to be used for the control to edit the parameter.
        ///  If the returned QVariant is invalid the value is not bounded from
        ///  below.
        ///          </remarks>        <short>    The minimum value to be used for the control to edit the parameter.</short>
        public QVariant MinimumValue() {
            return (QVariant) interceptor.Invoke("minimumValue", "minimumValue() const", typeof(QVariant));
        }
        /// <remarks>
        ///  The maximum value to be used for the control to edit the parameter.
        ///  If the returned QVariant is invalid the value is not bounded from
        ///  above.
        ///          </remarks>        <short>    The maximum value to be used for the control to edit the parameter.</short>
        public QVariant MaximumValue() {
            return (QVariant) interceptor.Invoke("maximumValue", "maximumValue() const", typeof(QVariant));
        }
        /// <remarks>
        ///  The default value.
        ///          </remarks>        <short>    The default value.</short>
        public QVariant DefaultValue() {
            return (QVariant) interceptor.Invoke("defaultValue", "defaultValue() const", typeof(QVariant));
        }
        /// <remarks>
        ///  The possible values to be used for the control to edit the parameter.
        ///  if the value of this parameter is to be picked from predefined values
        ///  this returns the list (otherwise it returns an empty QVariantList).
        ///          </remarks>        <short>    The possible values to be used for the control to edit the parameter.</short>
        public List<QVariant> PossibleValues() {
            return (List<QVariant>) interceptor.Invoke("possibleValues", "possibleValues() const", typeof(List<QVariant>));
        }
        /// <remarks>
        ///  \internal
        ///  compares the ids of the parameters
        ///          </remarks>        <short>    \internal  compares the ids of the parameters          </short>
        /// <remarks>
        ///  \internal
        ///  compares the ids of the parameters
        ///          </remarks>        <short>    \internal  compares the ids of the parameters          </short>
        /// <remarks>
        ///  \internal
        ///  compares the ids of the parameters
        ///          </remarks>        <short>    \internal  compares the ids of the parameters          </short>
        public override bool Equals(object o) {
            if (!(o is EffectParameter)) { return false; }
            return this == (EffectParameter) o;
        }
        public override int GetHashCode() {
            return interceptor.GetHashCode();
        }
        public EffectParameter(Phonon.EffectParameter rhs) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("EffectParameter#", "EffectParameter(const Phonon::EffectParameter&)", typeof(void), typeof(Phonon.EffectParameter), rhs);
        }
        /// <remarks>
        ///  Only to be used by backend implementations:
        ///  Creates a new effect parameter.
        ///  \param parameterId This is a number to uniquely identify the
        ///  parameter. The id is used for value() and setValue().
        ///  \param name The name/label for this parameter.
        ///  \param hints Sets the hints for the type of parameter.
        ///  \param defaultValue The value that should be used as a default.
        ///  \param min The minimum value allowed for this parameter. You only
        ///  need to set this if the BoundedBelowHint is set.
        ///  \param max The maximum value allowed for this parameter. You only
        ///  need to set this if the BoundedAboveHint is set.
        ///  \param description A descriptive text for the parameter
        ///  (explaining what it controls) to be used as a tooltip or
        ///  WhatsThis help.
        ///          </remarks>        <short>    Only to be used by backend implementations: </short>
        public EffectParameter(int parameterId, string name, uint hints, QVariant defaultValue, QVariant min, QVariant max, List<QVariant> values, string description) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("EffectParameter$$$###?$", "EffectParameter(int, const QString&, Phonon::EffectParameter::Hints, const QVariant&, const QVariant&, const QVariant&, const QList<QVariant>&, const QString&)", typeof(void), typeof(int), parameterId, typeof(string), name, typeof(uint), hints, typeof(QVariant), defaultValue, typeof(QVariant), min, typeof(QVariant), max, typeof(List<QVariant>), values, typeof(string), description);
        }
        public EffectParameter(int parameterId, string name, uint hints, QVariant defaultValue, QVariant min, QVariant max, List<QVariant> values) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("EffectParameter$$$###?", "EffectParameter(int, const QString&, Phonon::EffectParameter::Hints, const QVariant&, const QVariant&, const QVariant&, const QList<QVariant>&)", typeof(void), typeof(int), parameterId, typeof(string), name, typeof(uint), hints, typeof(QVariant), defaultValue, typeof(QVariant), min, typeof(QVariant), max, typeof(List<QVariant>), values);
        }
        public EffectParameter(int parameterId, string name, uint hints, QVariant defaultValue, QVariant min, QVariant max) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("EffectParameter$$$###", "EffectParameter(int, const QString&, Phonon::EffectParameter::Hints, const QVariant&, const QVariant&, const QVariant&)", typeof(void), typeof(int), parameterId, typeof(string), name, typeof(uint), hints, typeof(QVariant), defaultValue, typeof(QVariant), min, typeof(QVariant), max);
        }
        public EffectParameter(int parameterId, string name, uint hints, QVariant defaultValue, QVariant min) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("EffectParameter$$$##", "EffectParameter(int, const QString&, Phonon::EffectParameter::Hints, const QVariant&, const QVariant&)", typeof(void), typeof(int), parameterId, typeof(string), name, typeof(uint), hints, typeof(QVariant), defaultValue, typeof(QVariant), min);
        }
        public EffectParameter(int parameterId, string name, uint hints, QVariant defaultValue) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("EffectParameter$$$#", "EffectParameter(int, const QString&, Phonon::EffectParameter::Hints, const QVariant&)", typeof(void), typeof(int), parameterId, typeof(string), name, typeof(uint), hints, typeof(QVariant), defaultValue);
        }
        /// <remarks>
        ///  \internal
        ///  Returns the parameter's id.
        ///          </remarks>        <short>    \internal </short>
        public int Id() {
            return (int) interceptor.Invoke("id", "id() const", typeof(int));
        }
        ~EffectParameter() {
            interceptor.Invoke("~EffectParameter", "~EffectParameter()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~EffectParameter", "~EffectParameter()", typeof(void));
        }
        public static bool operator<(EffectParameter lhs, Phonon.EffectParameter rhs) {
            return (bool) staticInterceptor.Invoke("operator<#", "operator<(const Phonon::EffectParameter&) const", typeof(bool), typeof(EffectParameter), lhs, typeof(Phonon.EffectParameter), rhs);
        }
        public static bool operator>(EffectParameter lhs, Phonon.EffectParameter rhs) {
            return (bool) staticInterceptor.Invoke("operator>#", "operator>(const Phonon::EffectParameter&) const", typeof(bool), typeof(EffectParameter), lhs, typeof(Phonon.EffectParameter), rhs);
        }
        public static bool operator==(EffectParameter lhs, Phonon.EffectParameter rhs) {
            return (bool) staticInterceptor.Invoke("operator==#", "operator==(const Phonon::EffectParameter&) const", typeof(bool), typeof(EffectParameter), lhs, typeof(Phonon.EffectParameter), rhs);
        }
        public static bool operator!=(EffectParameter lhs, Phonon.EffectParameter rhs) {
            return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const Phonon::EffectParameter&) const", typeof(bool), typeof(EffectParameter), lhs, typeof(Phonon.EffectParameter), rhs);
        }
    }
}
