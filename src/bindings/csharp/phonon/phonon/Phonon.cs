//Auto-generated by kalyptus. DO NOT EDIT.
namespace Phonon {
    using Phonon;
    using System;
    using Qyoto;
    /// <remarks>
    ///  Enum to identify the media discs supported by MediaObject.
    ///  \see MediaSource(Phonon.DiscType, stringdeviceName)
    ///      </remarks>        <short>    Enum to identify the media discs supported by MediaObject.</short>
    public enum DiscType {
        NoDisc = -1,
        Cd = 0,
        Dvd = 1,
        Vcd = 2,
    }
    /// <remarks>
    ///  Provided as keys for MediaObject.MetaData for convenience, in addition to the strings defined in
    ///  the Ogg Vorbis specification.
    ///      </remarks>        <short>    Provided as keys for MediaObject.MetaData for convenience, in addition to the strings defined in  the Ogg Vorbis specification.</short>
    public enum MetaData {
        ArtistMetaData = 0,
        AlbumMetaData = 1,
        TitleMetaData = 2,
        DateMetaData = 3,
        GenreMetaData = 4,
        TracknumberMetaData = 5,
        DescriptionMetaData = 6,
        MusicBrainzDiscIdMetaData = 7,
    }
    /// <remarks>
    ///  The state the media producing object is in at the moment.
    ///  \see MediaObject
    ///      </remarks>        <short>    The state the media producing object is in at the moment.</short>
    public enum State {
        LoadingState = 0,
        StoppedState = 1,
        PlayingState = 2,
        BufferingState = 3,
        PausedState = 4,
        ErrorState = 5,
    }
    /// <remarks>
    ///  Set's the category your program should be listed in in the mixer.
    ///  A Jukebox will set this to Music, a VoIP program to Communication, a
    ///  DVD player to video, and so on.
    ///  <b>Note:<> These categories can also become useful for an application that
    ///  controls the volumes automatically, like turning down the music when a call
    ///  comes in, or turning down the notifications when the media player knows
    ///  it's playing classical music.
    ///  \see AudioOutput.SetCategory
    ///      </remarks>        <short>    Set's the category your program should be listed in in the mixer.</short>
    public enum Category {
        NoCategory = -1,
        NotificationCategory = 0,
        MusicCategory = 1,
        VideoCategory = 2,
        CommunicationCategory = 3,
        GameCategory = 4,
        AccessibilityCategory = 5,
        LastCategory = AccessibilityCategory,
    }
    /// <remarks>
    ///  Tells your program how to recover from an error.
    ///  \see MediaObject.ErrorType()
    ///      </remarks>        <short>    Tells your program how to recover from an error.</short>
    public enum ErrorType {
        NoError = 0,
        NormalError = 1,
        FatalError = 2,
    }
    /// <remarks>
    ///  Defines the type of information that is contained in a ObjectDescription
    ///  object.
    ///  \ingroup Backend
    ///      </remarks>        <short>    Defines the type of information that is contained in a ObjectDescription  object.</short>
    public enum ObjectDescriptionType {
        AudioOutputDeviceType = 0,
        EffectType = 1,
        AudioChannelType = 2,
        SubtitleType = 3,
        AudioCaptureDeviceType = 4,
    }
    /// <remarks>
    ///  \brief The %KDE Multimedia classes
    ///  In this Namespace you find the classes to access Multimedia functions for
    ///  audio and video playback. Those classes are not dependent
    ///  on any specific framework (like they were in pre KDE4 times) but rather use
    ///  exchangeable backends to do the work.
    ///  If you want to write a new backend take a look at \ref phonon_backend_development_page.
    ///  \author Matthias Kretz <kretz@kde.org>
    ///  </remarks>        <short>    \brief The %KDE Multimedia classes </short>
    [SmokeClass("Phonon")]
    public class Global {
        private static SmokeInvocation staticInterceptor = null;
        static Global() {
            staticInterceptor = new SmokeInvocation(typeof(Global), null);
        }
        /// <remarks>
        ///  Convenience function to create a MediaObject and AudioOutput connected by
        ///  a path.
        ///      </remarks>        <short>    Convenience function to create a MediaObject and AudioOutput connected by  a path.</short>
        public static Phonon.MediaObject CreatePlayer(Phonon.Category category, Phonon.MediaSource source) {
            return (Phonon.MediaObject) staticInterceptor.Invoke("createPlayer$#", "createPlayer(Phonon::Category, const Phonon::MediaSource&)", typeof(Phonon.MediaObject), typeof(Phonon.Category), category, typeof(Phonon.MediaSource), source);
        }
        public static Phonon.MediaObject CreatePlayer(Phonon.Category category) {
            return (Phonon.MediaObject) staticInterceptor.Invoke("createPlayer$", "createPlayer(Phonon::Category)", typeof(Phonon.MediaObject), typeof(Phonon.Category), category);
        }
        /// <remarks>
        ///  <see cref="Path"></see>
        ///  Creates a new Path connecting two MediaNodes.
        ///  The implementation will automatically select the right format and media type. E.g. connecting a
        ///  MediaObject and AudioOutput will create a Path object connecting the audio. This might be
        ///  represented as PCM or perhaps even AC3 depending on the AudioOutput object.
        ///  \param source The MediaNode to connect an output from
        ///  \param sink The MediaNode to connect to.
        ///  </remarks>        <short>    <see cref="Path"></see>  Creates a new Path connecting two MediaNodes.</short>
        public static Phonon.Path CreatePath(Phonon.IMediaNode source, Phonon.IMediaNode sink) {
            return (Phonon.Path) staticInterceptor.Invoke("createPath##", "createPath(Phonon::MediaNode*, Phonon::MediaNode*)", typeof(Phonon.Path), typeof(Phonon.IMediaNode), source, typeof(Phonon.IMediaNode), sink);
        }
        public static string PhononVersion() {
            return (string) staticInterceptor.Invoke("phononVersion", "phononVersion()", typeof(string));
        }
        /// <remarks>
        ///  Returns a (translated) string to show to the user identifying the given
        ///  Category.
        ///      </remarks>        <short>    Returns a (translated) string to show to the user identifying the given  Category.</short>
        public static string CategoryToString(Phonon.Category c) {
            return (string) staticInterceptor.Invoke("categoryToString$", "categoryToString(Phonon::Category)", typeof(string), typeof(Phonon.Category), c);
        }
        public static uint QHash(Phonon.EffectParameter param) {
            return (uint) staticInterceptor.Invoke("qHash#", "qHash(const Phonon::EffectParameter&)", typeof(uint), typeof(Phonon.EffectParameter), param);
        }
    }
}
