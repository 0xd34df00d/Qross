//Auto-generated by kalyptus. DO NOT EDIT.
namespace Phonon {
    using Phonon;
    using System;
    using Qyoto;
    using System.Collections.Generic;
    /// <remarks> \class Path path.h Phonon/Path
    ///  \short Connection object providing convenient effect insertion
    ///  <pre>
    /// MediaObject media = new MediaObject;
    /// AudioOutput output = new AudioOutput(Phonon.MusicCategory);
    /// Path path = Phonon.CreatePath(media, output);
    /// Q_ASSERT(path.isValid()); // for this simple case the path should always be
    ///                           //valid - there are unit tests to ensure it
    /// // insert an effect
    /// QList<EffectDescription> effectList = BackendCapabilities.AvailableAudioEffects();
    /// if (!effectList.isEmpty()) {
    ///     Effect effect = path.insertEffect(effectList.first());
    /// }
    ///  </pre>
    ///  \ingroup Playback
    ///  \ingroup Recording
    ///  \author Matthias Kretz <kretz@kde.org>
    ///  \author Thierry Bastian <thierry.bastian@trolltech.com>
    ///  </remarks>        <short>   \class Path path.</short>
    [SmokeClass("Phonon::Path")]
    public class Path : Object, IDisposable {
        protected SmokeInvocation interceptor = null;
        private IntPtr smokeObject;
        protected Path(Type dummy) {}
        protected void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(Path), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static Path() {
            staticInterceptor = new SmokeInvocation(typeof(Path), null);
        }
        // Phonon::Effect* insertEffect(const Phonon::ObjectDescription<Phonon::EffectType>& arg1,Phonon::Effect* arg2); >>>> NOT CONVERTED
        // Phonon::Effect* insertEffect(const Phonon::ObjectDescription<Phonon::EffectType>& arg1); >>>> NOT CONVERTED
        /// <remarks>
        ///  Creates an invalid path.
        ///  You can still make it a valid path by calling reconnect. To create a path you should use
        ///  createPath, though.
        ///  \see createPath
        ///  \see isValid
        ///          </remarks>        <short>    Creates an invalid path.</short>
        public Path() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Path", "Path()", typeof(void));
        }
        /// <remarks>
        ///  Constructs a copy of the given path.
        ///  This constructor is fast thanks to explicit sharing.
        ///          </remarks>        <short>    Constructs a copy of the given path.</short>
        public Path(Phonon.Path arg1) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("Path#", "Path(const Phonon::Path&)", typeof(void), typeof(Phonon.Path), arg1);
        }
        /// <remarks>
        ///  Returns whether the path object connects two MediaNodes or not.
        ///  \return <pre>true</pre> when the path connects two MediaNodes
        ///  \return <pre>false</pre> when the path is disconnected
        ///          </remarks>        <short>    Returns whether the path object connects two MediaNodes or not.</short>
        public bool IsValid() {
            return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
        }
        /// <remarks>
        ///  Creates and inserts an effect into the path.
        ///  You may insert effects of the same class as often as you like,
        ///  but if you insert the same object, the call will fail.
        ///  \param desc The EffectDescription object for the effect to be inserted.
        ///  \param insertBefore If you already inserted an effect you can
        ///  tell with this parameter in which order the data gets
        ///  processed. If this is <code>0</code> the effect is appended at the end of
        ///  the processing list. If the effect has not been inserted before
        ///  the method will do nothing and return <code>false</code>.
        ///  \return Returns a pointer to the effect object if it could be inserted
        ///  at the specified position. If <code>0</code> is returned the effect was not
        ///  inserted.
        ///  \see removeEffect
        ///  \see effects
        ///          </remarks>        <short>    Creates and inserts an effect into the path.</short>
        /// <remarks>
        ///  Inserts an effect into the path.
        ///  You may insert effects of the same class as often as you like,
        ///  but if you insert the same object, the call will fail.
        ///  \param newEffect An Effect object.
        ///  \param insertBefore If you already inserted an effect you can
        ///  tell with this parameter in which order the data gets
        ///  processed. If this is <code>0</code> the effect is appended at the end of
        ///  the processing list. If the effect has not been inserted before
        ///  the method will do nothing and return <code>false</code>.
        ///  \return Returns whether the effect could be inserted at the
        ///  specified position. If <code>false</code> is returned the effect was not
        ///  inserted.
        ///  \see removeEffect
        ///  \see effects
        ///          </remarks>        <short>    Inserts an effect into the path.</short>
        public bool InsertEffect(Phonon.Effect newEffect, Phonon.Effect insertBefore) {
            return (bool) interceptor.Invoke("insertEffect##", "insertEffect(Phonon::Effect*, Phonon::Effect*)", typeof(bool), typeof(Phonon.Effect), newEffect, typeof(Phonon.Effect), insertBefore);
        }
        public bool InsertEffect(Phonon.Effect newEffect) {
            return (bool) interceptor.Invoke("insertEffect#", "insertEffect(Phonon::Effect*)", typeof(bool), typeof(Phonon.Effect), newEffect);
        }
        /// <remarks>
        ///  Removes an effect from the path.
        ///  If the effect gets deleted while it is still connected the effect
        ///  will be removed automatically.
        ///  \param effect The effect to be removed.
        ///  \return Returns whether the call was successful. If it returns
        ///  <code>false</code> the effect could not be found in the path, meaning it
        ///  has not been inserted before.
        ///  \see insertEffect
        ///  \see effects
        ///          </remarks>        <short>    Removes an effect from the path.</short>
        public bool RemoveEffect(Phonon.Effect effect) {
            return (bool) interceptor.Invoke("removeEffect#", "removeEffect(Phonon::Effect*)", typeof(bool), typeof(Phonon.Effect), effect);
        }
        /// <remarks>
        ///  Returns a list of Effect objects that are currently
        ///  used as effects. The order in the list determines the order the
        ///  signal is sent through the effects.
        ///  \return A list with all current effects.
        ///  \see insertEffect
        ///  \see removeEffect
        ///          </remarks>        <short>    Returns a list of Effect objects that are currently  used as effects.</short>
        public List<Phonon.Effect> Effects() {
            return (List<Phonon.Effect>) interceptor.Invoke("effects", "effects() const", typeof(List<Phonon.Effect>));
        }
        /// <remarks>
        ///  Tries to change the MediaNodes the path is connected to.
        ///  If reconnect fails the old connection is kept.
        ///          </remarks>        <short>    Tries to change the MediaNodes the path is connected to.</short>
        public bool Reconnect(Phonon.IMediaNode source, Phonon.IMediaNode sink) {
            return (bool) interceptor.Invoke("reconnect##", "reconnect(Phonon::MediaNode*, Phonon::MediaNode*)", typeof(bool), typeof(Phonon.IMediaNode), source, typeof(Phonon.IMediaNode), sink);
        }
        /// <remarks>
        ///  Disconnects the path from the MediaNodes it was connected to. This invalidates the path
        ///  (isValid returns <pre>false</pre> then).
        ///          </remarks>        <short>    Disconnects the path from the MediaNodes it was connected to.</short>
        public bool Disconnect() {
            return (bool) interceptor.Invoke("disconnect", "disconnect()", typeof(bool));
        }
        /// <remarks>
        ///  Returns <pre>true</pre> if this Path is equal to <pre>p</pre>; otherwise returns <pre>false</pre>;
        ///          </remarks>        <short>    Returns \p true if this Path is equal to \p p; otherwise returns \p false;          </short>
        public override bool Equals(object o) {
            if (!(o is Path)) { return false; }
            return this == (Path) o;
        }
        public override int GetHashCode() {
            return interceptor.GetHashCode();
        }
        /// <remarks>
        ///  Returns the source MediaNode used by the path.
        ///          </remarks>        <short>    Returns the source MediaNode used by the path.</short>
        public Phonon.IMediaNode Source() {
            return (Phonon.IMediaNode) interceptor.Invoke("source", "source() const", typeof(Phonon.IMediaNode));
        }
        /// <remarks>
        ///  Returns the sink MediaNode used by the path.
        ///          </remarks>        <short>    Returns the sink MediaNode used by the path.</short>
        public Phonon.IMediaNode Sink() {
            return (Phonon.IMediaNode) interceptor.Invoke("sink", "sink() const", typeof(Phonon.IMediaNode));
        }
        ~Path() {
            interceptor.Invoke("~Path", "~Path()", typeof(void));
        }
        public void Dispose() {
            interceptor.Invoke("~Path", "~Path()", typeof(void));
        }
        public static bool operator==(Path lhs, Phonon.Path p) {
            return (bool) staticInterceptor.Invoke("operator==#", "operator==(const Phonon::Path&) const", typeof(bool), typeof(Path), lhs, typeof(Phonon.Path), p);
        }
        public static bool operator!=(Path lhs, Phonon.Path p) {
            return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const Phonon::Path&) const", typeof(bool), typeof(Path), lhs, typeof(Phonon.Path), p);
        }
    }
}
